#!/usr/bin/env python

import os
import sys
import argparse
import glob
from textwrap import wrap, fill

import numpy as np
import pandas as pd
import altair as alt

sys.path.append("/net/bbi/vol1/data/sge-analysis/lib/")
import sge_target
import sge_counts
import sge_util
import sge_altair


palette = [
    '#006616', # dark green,
    '#81B4C7', # dusty blue
    '#ffcd3a', # yellow
    '#6AA84F', # med green
    '#93C47D', # light green
    '#888888', # med gray
    '#000000', # black
    '#1170AA', # darker blue
    '#CFCFCF' # light gray
]


variant_types = [
    'synonymous_variant',
    'missense_variant',  
    'stop_gained',
    'intron_variant', 
    'UTR_variant',
    'stop_lost',
    'start_lost',
    'splice_site_variant', 
    'splicing_variant',
]

def get_simplified_consequence(vep_terms, ensemblfile):
    consequence_df = pd.read_csv(ensemblfile, sep='\t')
    # Create a dictionary mapping terms to their SO summary term (prioritizing importance)
    mapping_dict = (
        consequence_df.sort_values(by="Importance", ascending=False)
        .groupby("VEP output term")[["SO summary term", "Importance"]]
        .first()
        .to_dict()["SO summary term"]
    )
    if not isinstance(vep_terms, str):
        return "Unknown"
    terms = vep_terms.split(',')
    matched_terms = [mapping_dict.get(term.strip()) for term in terms if term.strip() in mapping_dict]

    return matched_terms[0] if matched_terms else "Unknown"


def make_uniformity_figures(target, libfile):
    libdf = sge_counts.getSNVCounts(libfile, augment=False, pseudocount=0)
    libdf = libdf[(libdf["pos"] >= target.editstartpos) & 
                  (libdf["pos"] <= target.editendpos)]
    libdf = libdf.merge(target.refdf, on="pos")
    libdf = libdf[libdf["ref"] != libdf["allele"]]
    libdf = libdf[~libdf["pos"].isin(target.required_edits)]
    libdf = libdf[~libdf["pos"].isin(target.skip_pos)]
    libdf["pos_id"] = libdf["pos"].astype(str) + ":" + libdf["allele"]

    a = alt.Chart(libdf, height=150, width=1000).mark_point(filled=True, size=30).encode(
        x=alt.X('pos_id:N', title="Variant" ,sort='y').axis(None),
        y=alt.Y('count:Q', title="SNV library count", scale=alt.Scale()),
        color=alt.Color('allele:N', title="Allele", scale=alt.Scale(scheme="category10")),
    )

    b = alt.Chart(libdf, height=150, width=1000).mark_point(filled=True, size=50).encode(
        x=alt.X('pos:N', title="Position" ,sort='x', axis=alt.Axis(labelFontSize=10)),
        y=alt.Y('count:Q', title="SNV library count", scale=alt.Scale()),
        color=alt.Color('allele:N', title="Allele"),
    )
    chart = (a & b)
    return chart


def make_correlation_figures(target, sampledict, day, args):
    maxcount = args.maxcount
    figlist = []
    for index, repl1 in enumerate(sampledict[day]):
        fn = repl1.split("/")[-1]
        parts = fn.split(".")[0].split("_")
        repl = parts[2]
        if repl == 'NC': # throw out the negative control
            continue
        for repl2 in sampledict[day][index+1:]:
            fn = repl2.split("/")[-1]
            parts = fn.split(".")[0].split("_")
            repl = parts[2]
            if repl == 'NC': # throw out the negative control
                continue

            s1counts = sge_counts.getSNVCounts(repl1, augment=False, pseudocount=0)
            s2counts = sge_counts.getSNVCounts(repl2, augment=False, pseudocount=0)
            s1counts = s1counts.rename(columns={'count': 'count_s1'})
            s2counts = s2counts.rename(columns={'count': 'count_s2'})
            tmpdf = s1counts.merge(s2counts, on=["chrom", "pos", "allele"])
            tmppf = tmpdf[(tmpdf["pos"] >= target.editstartpos) & (tmpdf["pos"] <= target.editendpos)]
            tmpdf = tmpdf.merge(target.refdf, on="pos")
            tmpdf = tmpdf[tmpdf["ref"] != tmpdf["allele"]]
            tmpdf = tmpdf[~tmpdf["pos"].isin(target.required_edits)]
            tmpdf = tmpdf[~tmpdf["pos"].isin(target.skip_pos)]
            tmpdf = tmpdf[tmpdf["count_s1"] <= maxcount]
            tmpdf = tmpdf[tmpdf["count_s2"] <= maxcount]
            tmpdf = tmpdf[tmpdf["count_s1"] > 0]
            tmpdf = tmpdf[tmpdf["count_s2"] > 0]
            
            # compute SNV correlation
            mycorr = tmpdf[["count_s1", "count_s2"]].corr().iloc[0,1]
            p = alt.Chart(tmpdf).mark_point().encode(
                x=alt.X("count_s1:Q", title=wrap(repl1, width=40)).scale(type='log').axis(titleFontSize=8),#"%s"% repl1.split("/")[-1].split(".")[0]).scale(type='log'),
                y=alt.Y("count_s2:Q", title=wrap(repl2, width=40)).scale(type='log').axis(titleFontSize=8),#"%s"% repl2.split("/")[-1].split(".")[0]).scale(type='log'),

            )
            t = alt.Chart({'values':[{}]}).mark_text(
                align="left", baseline="top"
                ).encode(
                x=alt.value(5),  # pixels from left
                y=alt.value(5),  # pixels from top
                text=alt.value(f"r: {mycorr:.3f}"),
            )
            figlist.append(p + t)# + p.transform_regression("count_s2", "count_s1").mark_line())
    
    return figlist


def make_counts_figures(target, sampledict, day, args):
    maxcount = args.maxcount
    figlist = []
    sampledict[day] = sorted(sampledict[day])
    nsamples = len(sampledict[day])
    for index, repl1 in enumerate(sampledict[day]):
        tmpdf = sge_counts.getSNVCounts(repl1, augment=False, pseudocount=0)
        tmppf = tmpdf[(tmpdf["pos"] >= target.editstartpos) & (tmpdf["pos"] <= target.editendpos)]
        tmpdf = tmpdf.merge(target.refdf, on="pos")
        tmpdf = tmpdf[tmpdf["ref"] != tmpdf["allele"]]
        tmpdf = tmpdf[~tmpdf["pos"].isin(target.required_edits)]
        tmpdf = tmpdf[~tmpdf["pos"].isin(target.skip_pos)]
        tmpdf = tmpdf[tmpdf["count"] <= maxcount]
        if index == nsamples - 1:
            a = alt.Chart(tmpdf, height=150, width=1000).mark_point(filled=True, size=50).encode(
                x=alt.X(
                    'pos:N',
                    title="Position",
                    sort='x',
                    axis=alt.Axis(
                        labelFontSize=10
                    )
                ),
                y=alt.Y(
                    'count:Q',
                    title=wrap(repl1, width=40),#repl1.split("/")[-1].split(".")[0].split("_",2 )[2],
                    scale=alt.Scale()
                ).axis(titleFontSize=8),
                color=alt.Color('allele:N', title="Allele"),
            )
        else:
            a = alt.Chart(tmpdf, height=150, width=1000).mark_point(filled=True, size=50).encode(
                x=alt.X(
                    'pos:N',
                    title="Position",
                    sort='x',
                    axis=alt.Axis(
                        labelFontSize=10)
                ).axis(None
                ),
                y=alt.Y(
                    'count:Q',
                    title=wrap(repl1, width=40),#repl1.split("/")[-1].split(".")[0].split("_",2 )[2],
                    scale=alt.Scale()).axis(titleFontSize=8),
                color=alt.Color('allele:N', title="Allele"),
            )
        figlist.append(a)
    return figlist


def make_log2ratio_figures(target, sampledict, vepfile, day):
    figlist = []

    # load starting library
    libfile = sampledict['D00'][0]
    df = sge_counts.getSNVCounts(libfile,
                                 augment=True,
                                 pseudocount=1)
    df = df.rename(columns={'count': 'snvlib_count'}
        ).drop(columns=["sampleid", "repl", "day"])
    statsfile = libfile.replace(".snvs.tsv", ".readstats.tsv")
    statsdf = sge_counts.getReadStats(statsfile, augment=False)
    normval = statsdf["snv_reads"][0]
    df['snvlib_freq'] = df['snvlib_count'] / normval

    cols_to_plot = []
        
    for snvfile in sorted(sampledict[day]):
        fn = snvfile.split("/")[-1]
        parts = fn.split(".")[0].split("_")
        repl = parts[2]
        if repl == 'NC': # throw out the negative control
            continue
        
        tmpdf = sge_counts.getSNVCounts(snvfile,
                                        augment=False,
                                        pseudocount=1)
        statsfile = snvfile.replace(".snvs.tsv", ".readstats.tsv")
        statsdf = sge_counts.getReadStats(statsfile, augment=False)
        #sampleid = tmpdf["sampleid"][0]
        sampleid = snvfile.replace(".snvs.tsv", "").split("/")[-1]
        parts = sampleid.split("_")
        #repl = parts[2]
        repl = '_'.join(parts[2:])
        countcol = "%s_%s" % (day, repl)
        tmpdf = tmpdf.rename(columns={'count': countcol})
        freqcol = countcol + "_freq"
        normval = statsdf["snv_reads"][0]
        tmpdf[freqcol] = tmpdf[countcol] / normval
        df = df.merge(tmpdf[["chrom", "pos", "allele", countcol, freqcol]], on=["chrom", "pos", "allele"])
        freqcol = "%s_%s_freq" % (day, repl)
        ratiocol = "%s_%s_over_lib" % (day, repl)
        df[ratiocol] = df[freqcol] / df['snvlib_freq']
        log2col = "%s_%s_over_lib_log2" % (day, repl)
        df[log2col] = np.log2(df[ratiocol])
        cols_to_plot.append(log2col)
    
    # filter dataframe
    df = df[(df["pos"] >= target.editstartpos) &
            (df["pos"] <= target.editendpos)]
    # merge with the reference sequence
    df = df.merge(target.refdf, on="pos")
    df = df[df["ref"] != df["allele"]]
    df["pos_id"] = df["pos"].astype(str) + ":" + df["allele"]
    # pivot and annotate with metadata
    df["pam_edit_or_snp"] = False
    df.loc[df["pos"].isin(target.required_edits), "pam_edit_or_snp"] = True
    df.loc[df["pos"].isin(target.skip_pos), "pam_edit_or_snp"] = True
    df = df[df["pam_edit_or_snp"] == False]

    # annotate with vep preditions
    vepdf = sge_util.getVEPdf(vepfile)
    df = df.merge(vepdf[["pos", "allele", "Consequence"]],
                  on=["pos", "allele"])
    
    df["simplified_consequence"] = df["Consequence"].apply(
        get_simplified_consequence,
        ensemblfile="/net/bbi/vol1/data/sge-analysis/etc/extended_ensembl_consequence.tsv"
    )

    #df['Consequence'] = df['Consequence'].map(lambda x: x.split(",")[0])
    #df["shortconsequence"] = df["Consequence"].map(lambda x: x.split("_")[0])

    for index, c in enumerate(cols_to_plot):
        title = c.replace("_over_lib_log2", "")
        if index == len(cols_to_plot) - 1:
            a = alt.Chart(df, height=150, width=1000).mark_point(filled=True, size=50).encode(
                x=alt.X(
                    'pos:N',
                    title="Position",
                    sort='x',
                    axis=alt.Axis(
                        labelFontSize=10
                    )
                ),
                y=alt.Y(
                    '%s:Q' % c,
                    title=title,
                ),
                color=alt.Color(
                    'simplified_consequence:N',
                    title="Variant type"
                ).scale(range=palette, domain=variant_types),
            )
        else:
            a = alt.Chart(df, height=150, width=1000).mark_point(filled=True, size=50).encode(
                x=alt.X(
                    'pos:N',
                    title="Position",
                    sort='x',
                    axis=alt.Axis(
                        labelFontSize=10)
                ).axis(
                    None
                ),
                y=alt.Y(
                    '%s:Q' % c,
                    title=title
                ),
                color=alt.Color(
                    'simplified_consequence:N',
                    title="Variant type"
                ).scale(range=palette, domain=variant_types),
            )
        figlist.append(a)
        
    meltdf = pd.melt(df, id_vars=['target', 'gene', 'pos_id', 'simplified_consequence'], value_vars=cols_to_plot)
    repfig = alt.Chart(
        meltdf[~meltdf["value"].isna()],
        height=200,
        width=1000
    ).mark_point(
        filled=True, size=50
    ).encode(
        x=alt.X(
            'pos_id:N',
            title="Position + Allele",
            sort='y', axis=alt.Axis(
                labelFontSize=8
            )
        ),
        y=alt.Y(
            'value:Q',
            title="Replicate log2 ratios, day %s" % day,
            scale=alt.Scale()
        ),
        color=alt.Color(
            'simplified_consequence:N',
            title="Variant type",
            #scale=alt.Scale(
            #    scheme="category10"
        ).scale(range=palette, domain=variant_types)
    )
    
    figlist.append(repfig)
    return figlist



def getSNVSamplesPendingRelease(target, include_neg=False):
    '''performs a directory lookup of all SNV counts files matching a 
    specific target name in the pending and release directories
    and returns a dictionary of filenames:
    (string) day --> [ (string) full_filename1, (string) full_filename2, ... ]

    if include_neg is True, the negative control sample is included; otherwise it is
    excluded from the list of samples

    '''
    samples = {}
    pendingdir = "/net/bbi/vol1/data/sge-seq/pending/counts/%s/" % target.gene
    releasedir = "/net/bbi/vol1/data/sge-seq/release/counts/%s/" % target.gene

    for fullfn in glob.glob("%s/%s_*.snvs.tsv" % (pendingdir, target.targetname)):
        fn = fullfn.split("/")[-1]
        parts = fn.split(".")[0].split("_")
        repl = parts[2]
        if not include_neg:
            if repl == 'NC': # throw out the negative control
                continue
        day = parts[3]
        if day not in samples:
            samples[day] = []
        samples[day].append(fullfn)

    for fullfn in glob.glob("%s/%s_*.snvs.tsv" % (releasedir, target.targetname)):
        fn = fullfn.split("/")[-1]
        parts = fn.split(".")[0].split("_")
        repl = parts[2]
        if not include_neg:
            if repl == 'NC': # throw out the negative control
                continue
        day = parts[3]
        if day not in samples:
            samples[day] = []
        samples[day].append(fullfn)

    return samples


def getSNVCountsFilesFromDir(target, dir, samples={}, include_neg=False):
    sys.stderr.write("INFO: looking for counts in %s\n" % dir)
    for fullfn in glob.glob("%s/%s_*.snvs.tsv" % (dir, target.targetname)):

        fn = fullfn.split("/")[-1]
        parts = fn.split(".")[0].split("_")
        repl = parts[2]
        if not include_neg:
            if repl == 'NC': # throw out the negative control
                continue
        day = parts[3]
        if day not in samples:
            samples[day] = []
        samples[day].append(fullfn)
        sys.stderr.write("INFO: found %s, day %s\n" % (fullfn, day))

    return samples


def build_figure(target, args):
    if args.pending:
        sampledict = getSNVCountsFilesFromDir(
            target, 
            "/net/bbi/vol1/data/sge-seq/pending/counts/%s/" % target.gene
        )
        sampledict = getSNVCountsFilesFromDir(
            target, 
            "/net/bbi/vol1/data/sge-seq/release/counts/%s/" % target.gene, 
            sampledict
        )
    else:
        sampledict = {}
        for dir in args.countsdir:
            try:
                sampledict = getSNVCountsFilesFromDir(
                    target, 
                    dir, 
                    sampledict
                )
            except:
                sys.stderr.write("ERROR: unable to get sample list from %s, exiting\n" % dir)
                sys.exit(-99)

        
    try:
        vepfile = "/net/bbi/vol1/data/sge-analysis/etc/%s/%s.snvs.vep.tsv" % (target.gene, target.targetname)
        chart = make_uniformity_figures(target, sampledict["D00"][0])
        #sampledict = target.getSNVSampleList(args.countsdir, include_neg=True)            
        days = sorted(sampledict.keys())
        if days[0] == "D00":
            days = days[1:]
        sys.stderr.write("INFO: will process data from days %s\n" % (", ".join(days)))
        countsplots = {}
        correlationplots = {}
        logratioplots = {}
        for d in days:
            countsplots[d] = make_counts_figures(target, sampledict, d, args)
            correlationplots[d] = make_correlation_figures(target, sampledict, d, args)
            logratioplots[d] = make_log2ratio_figures(target, sampledict, vepfile, d)
            
        # mws edits June 10
        corrlayouts = []
        for d in days:
            #print("working on",  d)
            if len(correlationplots[d]) > 0:
                layout = correlationplots[d][0]
                for cplot in correlationplots[d][1:]:
                    layout |= cplot
                layout = layout.properties(
                    title='Pearson correlation. day %s' % d
                )
                corrlayouts.append(layout)
            else:
                layout = None
        

        countslayouts = []
        for d in days:
            layout = countsplots[d][0]
            for cplot in countsplots[d][1:]:
                layout &= cplot
            layout = layout.resolve_scale(
                y='shared'
            ).properties(
                title="Counts per variant per replicate, day %s" % d
            )
            countslayouts.append(layout)

        loglayouts = []
        for d in days:
            layout = logratioplots[d][0]
            for lplot in logratioplots[d][1:]:
                layout &= lplot
            layout = layout.properties(
                title=alt.TitleParams(
                    text='log2 ratios per variant, day %s' % d
                )
            ).resolve_scale(
                y='shared'
            )
            loglayouts.append(layout)
            
        fullplot = (chart.properties(
            title=alt.TitleParams(
                text=" ",
                subtitle='log2 ratios per variant, day 13'
            )
        ))
        for l in corrlayouts:
            fullplot &= l

        for l in countslayouts:
            fullplot &= l
        for l in loglayouts:
            fullplot &= l

        #fullplot &= repfig #&
        #corratiolayout
        fullplot = fullplot.properties(
            title=alt.TitleParams(
                text=["QC and statistics for %s" % target.targetname.replace("_", " "), " "],
                subtitle="Library uniformity",
                subtitleFontSize=18,
                subtitleFontStyle='bold',
            )
        ).configure_title(fontSize=20, 
            offset=5, 
            orient='top', 
            #anchor='middle',
        ).resolve_legend(
            color='independent'
        ).resolve_scale(
            color='independent'
        )

    except Exception as error:
        sys.stderr.write("ERROR: unable to build QC plot for target %s\n" % target.targetname)
        sys.stderr.write(error + "\n")
        sys.exit(-99)

    try:
        fullplot.save(args.outfile)
        sys.stderr.write("INFO: saved QC plot to %s\n" % args.outfile)
    except:
        sys.stderr.write("ERROR: unable to save QC plot to %s\n" % args.outfile)
        sys.exit(-99)
        
    return


def main():
    parser = argparse.ArgumentParser(
        prog='makeQCfigures',
        description='create QC figures for an SGE target as an HTML page'
    )
    parser.add_argument(
        '-n', '--targetname',
        required=True,
        help="Target name -- must match entry in <targetfile>"
    )
    parser.add_argument(
        '-t', '--targetfile',
        required=False,
        default="",
        help="File containing list of targets and expected edits (def. /net/bbi/vol1/data/sge-analysis/etc/<gene>/targets.tsv)"
    )
    parser.add_argument(
        '-c', '--countsdir',
        nargs="+",
        required=False,
        help="Directory containing counts files"
    )
    parser.add_argument(
        '-p', '--pending',
        required=False,
        default=False,
        action="store_true",
        help="Automatically look for files in sge-seq/pending and sge-seq/release"
    )
    parser.add_argument(
        '-o', '--outfile',
        required=True,
        help="Output file, must end with .html (html format) or .png (PNG format)"
    )
    parser.add_argument(
        '-m', '--maxcount',
        required=False,
        default=100000,
        type=int,
        help="Filter out any positions with counts above <maxcount>"
    )
    
    args = parser.parse_args()
    if not args.countsdir and not args.pending:
        sys.stderr.write("ERROR: must provide either -c <dir> or -p\n")
        sys.exit(-99)

    if not args.outfile.endswith(".html") and not args.outfile.endswith(".png"):
        sys.stderr.write("ERROR: the output file does not end with .html or .png\n")
        sys.exit(-99)
    
    parts = args.targetname.split("_")
    gene = parts[0]
    exon = parts[1]
    if not args.targetfile:
        targetfile = "/net/bbi/vol1/data/sge-analysis/etc/%s/targets.tsv" % gene
        
    else:
        targetfile = args.targetfile
    if not os.path.exists(targetfile):
        sys.stderr.write("ERROR: Can't find target file %s, exiting\n" % targetfile)
        sys.exit(-99)

    # create Target instance for the specific target name we specified
    target = sge_target.Target(args.targetname, targetfile)
    build_figure(target, args)
    return

    
if __name__ == '__main__':
    main()
